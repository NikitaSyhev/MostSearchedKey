//Этот проект создан с помощью классического шаблона
#include <iostream>
#include<unordered_map>

class DataManager {

public:

	int mostSearchedKey() { // создали функцию для поиска
		std::unordered_map<int, int> keyAmount; // создали контейнер unordered_map, который назвали keyAmount, для хранения ключей и их количества
		for (size_t i = 0; i < _keys.size(); i++) {// идем по циклу for, ищем внутри вектора _keys ( метод size() - возвращает размер вектора, и мы заказчиваем поиск на i = размеру вектора
			const auto& [it, isInserted] = keyAmount.insert({ // создаем переменные, в которые записываем it - в нее записывает ключ из _keys ( например, мы прошли через цифру 1, записали 1). 
			   _keys[i], 1 });// isInserted - булевая переменная, которая возвращает 0 или 1, в зависимости от того, смогли в пару встравить ключ или нет ( например, если мы во втором проходе ( i = 1) 
			//пытаемся встравить ключ 1, не получается, потому что мы его получили в первом проходе.
			//Поэтому возвращается 0. 
			// Переменная isInserted булевая, потому что мы используем метод insert, он при записе ключа в мапу проверяет, есть ли этот ключ, если да, возвращает 0, нет - 1.
			if (!isInserted) { // в случае если значение не записалось, заходим в IF
				int value = it->second; //присваеваем значению value ( как часто встречется ключ ) второе значение в паре
				value++;// увеличиваем на 1, означает, что у нас количество повторов увеличивается на 1
				keyAmount[_keys[i]] = value; // записываем valie в пару
			}
		}
		std::pair<int, int> key_biggestValue = { 0,0 };// создаем пару, изначальне значения которой 0 и 0, нужны для поиска максимума
		for (std::unordered_map<int, int>::const_iterator it = // запускаем цикл for для unordered_map, от первого до последнего ключа пробегаем. 
			keyAmount.begin();//const_iterator - постоянный итератор для последовательности ( мапы ).keyAmount.begin() - первый ключ, keyAmount.end() - последний ключ.
			it != keyAmount.end(); it++) {
			if (key_biggestValue.second < it->second) {// if для поиска максимума. Берем значение из пары (key_biggestValue.second ), сравниваем его с it second ( значение, куда мы записывали число повторов)
				key_biggestValue = std::make_pair(it->first,// если условие соблюдается, мы в пару key_biggestValue записываем значения максимума 
					it->second);// 
			}
		}
		return key_biggestValue.first;//из пары key_biggestValue возвращаем первое значение, так как оно хранит число, из _keys, а второе не возвращаем, так как оно хранит число повторов, а они по условию задачи не нужны
	}

private:
	std::vector<int> _keys = { 1,1,2,2,4,2,6,7,7,7,2 };//создали интовый вектор
};


int main() {
	setlocale(LC_ALL, "Russian");
	





















	return 0;
}